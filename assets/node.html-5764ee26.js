import{aK as n,P as a,Q as s,aQ as e}from"./framework-3ea382e1.js";const i={},o=e(`<h1 id="node" tabindex="-1"><a class="header-anchor" href="#node" aria-hidden="true">#</a> node</h1><h2 id="node-的概念" tabindex="-1"><a class="header-anchor" href="#node-的概念" aria-hidden="true">#</a> node 的概念</h2><p>node 并不是一门语言，运行时可以让 js 运行到服务端（底层用的是 v8 引擎构建的）</p><h2 id="node-的特点" tabindex="-1"><a class="header-anchor" href="#node-的特点" aria-hidden="true">#</a> node 的特点</h2><ol><li>非阻塞 i/o（异步的非阻塞）</li><li>事件驱动（支持 js 语法，但不支持 bom 和 dom）</li><li>具有内置模块（fs、path 等）</li></ol><p>node 中实现的 api 都是支持异步的，底层采用的是多线程模型</p><h3 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h3><p>默认创建 10 个线程</p><ol><li>多线程：可以同时执行多个任务，给每个请求分配一个线程，优点是可以并行，缺点是浪费资源。适合 cpu 密集型（压缩、加密）</li><li>单线程：只有一个，节约内存。不适合 cpu 密集型，适合 i/o 密集型。缺点是容易阻塞</li><li>事件驱动：按照事件的顺序来触发处理逻辑（事件环），读写操作完成后会放到对应的队列中，等待事件环来触发对应的事件</li></ol><h3 id="node-用处" tabindex="-1"><a class="header-anchor" href="#node-用处" aria-hidden="true">#</a> node 用处</h3><ol><li>编写前端工具、工具链（vite、rollup、webpack、gulp、脚手架等）</li><li>为前端服务后端，中间层（client、bff、格式化、云服务、跨域、代理）</li><li>聊天、socket、即时通讯、爬虫、ssr</li></ol><h3 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化" aria-hidden="true">#</a> 模块化</h3><p>前端最早是没有模块化的概念，node 中自己实现了一套模块化的规范。</p><p>commonjs 规范，定义如何导出一个模块</p><ol><li>每个 js 都是一个模块</li><li>模块使用 module.exports 导出</li><li>使用 require 导入使用模块</li></ol><p>模块有自己的加载方式</p><ol><li>如果引入的模块是一个内置模块，直接返回即可，从当前目录递归向上查找是否存在模块</li><li>找到 node_module 则会找到文件夹下同名的文件夹，看这个文件夹里的 package.json，main.js</li><li>文件模块，通过相对路径或决定路径引入的资源，文件不存在则会尝试添加.js .json .node 尾缀</li><li>如果仍未找到就会报错</li></ol><p>尽量避免模块的文件名和文件夹重名</p><h2 id="包管理工具" tabindex="-1"><a class="header-anchor" href="#包管理工具" aria-hidden="true">#</a> 包管理工具</h2><p>笔记常用的有 npm、cnpm、yarn 等，包管理工具不能混用</p><h3 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化" aria-hidden="true">#</a> 初始化</h3><p>npm init 可以帮助我们自动初始化一个 package.json 记录安装的依赖和我们当前包的信息（包：多个模块组成的叫做包）</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> init
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据步骤填写信息，初始化 package.json 后就可以安装自己所需的模块</p><h3 id="依赖类型" tabindex="-1"><a class="header-anchor" href="#依赖类型" aria-hidden="true">#</a> 依赖类型</h3><ul><li>项目依赖 dependencies</li><li>开发依赖 devDependencies</li><li>同等依赖 peearDependencies 要求你安装但是不安装也不报错</li><li>爱装不装 optionDepencies</li><li>打包依赖 捆绑打包</li></ul><p>也可以不区分依赖 全部安装成项目依赖</p><h3 id="版本管理" tabindex="-1"><a class="header-anchor" href="#版本管理" aria-hidden="true">#</a> 版本管理</h3><p>版本格式为 major.minor.patch 主版本.小版本.补丁版本 semver 一个版本规范，用来描述版本的</p><ul><li>内部测试 1.0.0-alpha.4</li><li>公开测试 1.0.0-beta.1</li><li>马上发布 1.0.0-rc.2</li></ul><p>版本号标识符</p><ul><li>~ 会匹配最近的小版本依赖包，比如~1.2.3 会匹配所有 1.2.x 版本，但是不包括 1.3.0</li><li>^ 会匹配最新的大版本依赖包，比如^1.2.3 会匹配所有 1.x.x 的包，包括 1.3.0，但是不包括 2.0.0</li><li>* 这意味着安装最新版本的依赖包</li></ul><h2 id="node-事件环" tabindex="-1"><a class="header-anchor" href="#node-事件环" aria-hidden="true">#</a> node 事件环</h2><p>我们调用的 nodeapi 都是交给我们 libuv 库来去实现的， 通过阻塞 i/o 来实现 异步通知完成的方式就是事件驱动</p><p>┌───────────────────────────┐ ┌─&gt;│ timers │ 放定时器 │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ pending callbacks │ 上一轮没执行完的在这来执行 │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ idle, prepare │ 内部使用 │ └─────────────┬─────────────┘ ┌───────────────┐ │ ┌─────────────┴─────────────┐ │ incoming: │ │ │ poll │&lt;─────┤ connections, │ 文件读写回调再这里来执行 │ └─────────────┬─────────────┘ │ data, etc. │ │ ┌─────────────┴─────────────┐ └───────────────┘ │ │ check │ 执行setImmiedate │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ └──┤ close callbacks │ socket.close() └───────────────────────────┘</p><h2 id="node-和浏览器的差异" tabindex="-1"><a class="header-anchor" href="#node-和浏览器的差异" aria-hidden="true">#</a> node 和浏览器的差异</h2><ol><li>node 中的全局对象 global，global 中属性可以直接在任意模块下访问，有一些属性也可以直接访问（exports、require、**dirname、**filename 等）</li><li>在 node 中没有浏览器提供的 document、window 和其他的对象。</li><li>node 中不需要考虑浏览器的版本，可以支持所有现代的 ES6-7-8-9-10，ES-Next 的 JavaScript。</li></ol><h2 id="node-基础使用" tabindex="-1"><a class="header-anchor" href="#node-基础使用" aria-hidden="true">#</a> node 基础使用</h2><h3 id="读取文件" tabindex="-1"><a class="header-anchor" href="#读取文件" aria-hidden="true">#</a> 读取文件</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// e:\\project\\node\\a\\b\\</span>
<span class="token comment">// join 为拼接路径</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// e:\\a</span>
<span class="token comment">// resolve 会解析出一个相对路径</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">extname</span><span class="token punctuation">(</span><span class="token string">&quot;a.main.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// .js</span>
<span class="token comment">// extname 会后去文件的扩展名</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,40),t=[o];function l(p,c){return a(),s("div",null,t)}const r=n(i,[["render",l],["__file","node.html.vue"]]);export{r as default};
